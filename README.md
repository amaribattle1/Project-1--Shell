Quash is a simple, custom-built command-line shell written in C, designed to execute common commands and support various shell features such as built-in commands, background processes, signal handling, process forking, and process termination. It mimics a basic Unix shell with an emphasis on understanding the inner workings of process management and signal handling.

Design Choices
1. Shell Architecture
The architecture of Quash is built around a loop-based approach where the shell continually prompts the user for commands, parses the input, and executes it in either the foreground or background. The shell distinguishes between built-in commands (like cd, pwd, exit, etc.) and external commands, which it executes by forking a child process and using execvp() to run the command.

Command Parsing
To parse the input command, we tokenize the user input using strtok(), separating the command and its arguments based on whitespace delimiters. The tokenized arguments are then passed to execvp() or processed by internal logic for built-in commands.

2. Built-in Commands
The following built-in commands are implemented:

cd: Changes the current working directory using chdir().
pwd: Prints the current working directory using getcwd().
echo: Prints a message to the screen and supports environment variable substitution.
exit: Terminates the shell program.
env: Displays the current environment variables.
setenv: Sets environment variables using setenv().
Each of these commands is handled in the main loop, where they are parsed and executed directly without needing to fork a new process.

3. Process Forking
For non-built-in commands, the shell forks a child process using fork(). The child process then executes the command using execvp(), and the parent process waits for it to complete unless the command is executed in the background (indicated by &).

Background Processes
When a command ends with &, it is executed as a background process. In this case, the shell does not wait for the process to complete, and it immediately returns to the prompt to accept new commands. This behavior is managed by checking for & in the argument list, removing it, and setting the background flag. If the background flag is set, the parent does not call waitpid() and allows the shell to return to the prompt immediately.

4. Signal Handling
The shell registers a signal handler for SIGINT (generated by pressing Ctrl+C). When this signal is received, the shell will display a message indicating it has caught the signal but will continue running, rather than terminating. This allows the shell to stay running even when Ctrl+C is pressed, preventing the shell from quitting unexpectedly.

5. Timer for Process Termination
To handle long-running foreground processes, the shell implements a timer using the alarm() function. The timer triggers a signal after 10 seconds, allowing the shell to terminate processes that have exceeded the time limit. This functionality ensures that long-running processes do not hang indefinitely.

6. Error Handling
The shell performs basic error checking:

If a command is not found, an error message is printed.
If execvp() fails, an error message is displayed.
If the cd command fails (e.g., due to a nonexistent directory), an error message is printed.
The shell checks for memory allocation and file system errors, reporting them to the user when necessary.
7. Command Redirection and Piping
While the core functionality focuses on executing commands, the shell can be extended to support I/O redirection (using >, <) and piping (|). These features can be added to handle scenarios like redirecting output to a file or passing output from one command to another as input. This is a planned feature for future extensions.

Code Documentation
1. Main Loop
The main loop is the heart of the shell. It prompts the user, reads input, parses the command, and either executes it as a built-in command or forks a new process to run an external command. The main loop repeats until the user types the exit command, terminating the shell.

c
Copy code
while (true) {
    // Print prompt
    // Read input
    // Tokenize the input into arguments
    // Execute the command (built-in or external)
    // Handle background processes
}
2. Built-in Command Execution
Built-in commands are handled within the main loop. The logic checks if the first argument corresponds to one of the built-in commands (e.g., cd, pwd, echo). If so, the shell processes the command directly, avoiding the need to fork a new process.

c
Copy code
if (strcmp(arguments[0], "cd") == 0) {
    // Change directory
} else if (strcmp(arguments[0], "pwd") == 0) {
    // Print working directory
} else if (strcmp(arguments[0], "exit") == 0) {
    // Exit the shell
}
3. External Command Execution
For commands that are not built-in, the shell forks a child process using fork() and then executes the command with execvp(). The child process runs the command, and the parent waits for it to complete, unless it is a background process.

c
Copy code
pid_t pid = fork();
if (pid == 0) {
    // Child process executes the command
    execvp(arguments[0], arguments);
    exit(1);  // If execvp fails
} else if (pid > 0) {
    // Parent process waits for the command to finish unless background is set
}
4. Background Process Handling
If the command ends with &, the shell removes & from the argument list and sets the background flag to 1. In the parent process, it does not wait for the child process to finish and immediately returns to the prompt.

c
Copy code
if (background == 1) {
    printf("[Running in background] PID: %d\n", pid);
} else {
    waitpid(pid, NULL, 0);  // Wait for foreground process
}
5. Signal Handling
The shell handles SIGINT (Ctrl+C) by registering a signal handler with signal(). This allows the shell to catch the signal, display a message, and return to the prompt instead of terminating.

c
Copy code
void handle_sigint(int sig) {
    printf("\nCaught signal %d. Type 'exit' to quit.\n", sig);
    printf("%s", prompt);
    fflush(stdout);
}
Conclusion
The Quash shell was designed to be a simple, yet functional, command-line interface that supports essential shell features such as command execution, background processing, built-in commands, signal handling, and process termination. This project provided valuable experience in system-level programming, including process management, signal handling, and working with system calls like fork(), execvp(), and waitpid(). Future improvements will focus on adding features such as I/O redirection and piping to further enhance the functionality of the shell.







### Getting started
There are various things you can do to quickly and efficiently configure your Codio Box to your exact requirements. 

### GUI Applications and the Virtual Desktop 
The Virtual Desktop allows you auto develop GUI based applications using any programming language. You can install a Virtual Desktop in your Box. You can then start the desktop and view it within the Codio IDE or in a new browser tab.

[Virtual Desktop documentation](https://codio.com/docs/ide/boxes/installsw/gui/)


### Command line access and the Terminal window
All Codio Boxes provide sudo level privileges to the underlying Ubuntu server. This means you can install and configure any component you like. You access the terminal from the **Tools->Terminal** menu item.

### Debugger
The Codio IDE comes with a powerful visual debugger. Currently we support Python, Java, C, C++ and NodeJS. Other languages can be added on request.

[Debugger documentation](https://codio.com/docs/ide/features/debugging/)


### Content authoring and assessments
Codio comes with a very powerful content authoring tool, Codio Guides. Guides is also where you create all forms of auto-graded assessments. 

- [Guides documentation](https://codio.com/docs/content/authoring/overview/)
- [Assessments documentation](https://codio.com/docs/content/authoring/assessments/)

### Templating Box configurations and projects
Codio offers two very powerful templating options so you can create new projects from those templates with just a couple of clicks. **Stacks** allow you to create snapshots of the Boxâ€™s underlying software configuration. You can then create new projects from a Stack avoiding having to configure anew each time you start a new project. **Starter Packs** allow you to template an entire project, including workspace code.

- [Stacks documentation](https://codio.com/docs/project/stacks/)
- [Starter Packs documentation](https://codio.com/docs/project/packs/)

### Install software
You can always install software onto your Box using the command line. However, Codio offers a shortcut for commonly installed components that can be accessed from the **Tools->Install Software** menu.

We can easily add new items to the Install Software screen, so feel free to submit requests.

[Install Software documentation](https://codio.com/docs/ide/boxes/installsw/box-parts/)# Project-1--Shell
